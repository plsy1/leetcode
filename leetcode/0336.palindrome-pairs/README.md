##### 336.回文对

> 给定一组 互不相同 的单词， 找出所有不同 的索引对(i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。
>
>  
>
> 示例 1：
>
> 输入：["abcd","dcba","lls","s","sssll"]
> 输出：[[0,1],[1,0],[3,2],[2,4]] 
> 解释：可拼接成的回文串为 ["dcbaabcd","abcddcba","slls","llssssll"]
>
> 示例 2：
>
> 输入：["bat","tab","cat"]
> 输出：[[0,1],[1,0]] 
> 解释：可拼接成的回文串为 ["battab","tabbat"]

##### 解题思路

思路很容易想到，两层for循环拼接字符串后检测新串是否为回文串，想都别想肯定超时。

**优化**

整体哈希：

将字符串存入哈希表，反转字符串在哈希表中搜索，这步就有效的降低了时间复杂度，不必判断是否回文，且省去了拼接字符串的步骤。

局部哈希：

假设两个字符串`string m = "abccb"，n = a`，拼接起来是有两种可能的，即`m+n`和`n+m`,前者拼接得到的字符串显然是个回文串，且注意到`string foo = m.substr(1)`是个回文串，那我们只对`string bar = m.substr(0,1)`的部分进行反转并搜索就可以了。



总的来说分三种情况：

- 整体反转并搜索
- 字符串后半部分为回文串，反转前半部分并搜索
- 字符串前半部分为回文串，反转后半部分并搜索



