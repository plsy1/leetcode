**解题思路**

题目描述有点晦涩，大体意思就是说：一棵树加了一条边，构成了一个图，目的是删除一条边恢复成二叉树当状态，把删除后能够恢复成二叉树的边当作结果返回。

###### **注意事项**

因为题目要求返回最后出现的那条边，所以应该从后向前遍历。

###### 并查集

通过这个题学习了一波并查集的操作，记录一下。。。

并查集的操作主要有：

- 查找
- 合并
- 路径压缩

查找即找到当前元素所属的集合，合并即将两个集合合并为一个集合，路径压缩......就是路径压缩。

查找的C++代码示例：

```C++
//初始化
vector<int> father;
for (int i = 1; i <= len; ++i) father[i] = i;
//查找同时路径压缩
int find(int n) {
	if(father[n] == n) return n;
    return father[n] = find(father[n]);
}
```

合并需两个集合的祖先A与B，使A指向B或B指向A，将AB合并到一棵树上：

```c++
int fx = find(edges[i][0]), fy = find(edges[i][1]);
if (fx != fy) father[fx] = fy;
```



由于树的所有节点入度均为1且不成环，此题给出的树+边构成的图有两种状态：

- 存在入度为2的边
- 不存在入度为2的边

**算法设计思路**

1. 统计每一个节点的入度
2. 找到入度为2的节点，若删除指向这个节点的边后形成一棵树，返回这条边。
3. 找到入度为1的节点，若删除指向这个节点的边后形成一颗树，返回这条边。

